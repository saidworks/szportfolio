# Security Penetration Testing Script for Portfolio CMS
# This script performs basic security checks against the running application

param(
    [Parameter(Mandatory=$true)]
    [string]$BaseUrl,
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "./security-test-results.txt"
)

Write-Host "==================================" -ForegroundColor Cyan
Write-Host "Portfolio CMS Security Pen Test" -ForegroundColor Cyan
Write-Host "==================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Target: $BaseUrl" -ForegroundColor Yellow
Write-Host "Output: $OutputPath" -ForegroundColor Yellow
Write-Host ""

$results = @()
$passCount = 0
$failCount = 0

function Test-SecurityCheck {
    param(
        [string]$TestName,
        [scriptblock]$TestScript
    )
    
    Write-Host "Testing: $TestName..." -NoNewline
    
    try {
        $result = & $TestScript
        if ($result.Passed) {
            Write-Host " PASS" -ForegroundColor Green
            $script:passCount++
        } else {
            Write-Host " FAIL" -ForegroundColor Red
            $script:failCount++
        }
        $script:results += [PSCustomObject]@{
            Test = $TestName
            Status = if ($result.Passed) { "PASS" } else { "FAIL" }
            Details = $result.Details
        }
    } catch {
        Write-Host " ERROR" -ForegroundColor Red
        $script:failCount++
        $script:results += [PSCustomObject]@{
            Test = $TestName
            Status = "ERROR"
            Details = $_.Exception.Message
        }
    }
}

# Test 1: Security Headers
Test-SecurityCheck "Security Headers Present" {
    $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/health" -Method Get -UseBasicParsing
    $headers = $response.Headers
    
    $requiredHeaders = @(
        "X-Content-Type-Options",
        "X-Frame-Options",
        "X-XSS-Protection",
        "Referrer-Policy",
        "Content-Security-Policy"
    )
    
    $missingHeaders = $requiredHeaders | Where-Object { -not $headers.ContainsKey($_) }
    
    return @{
        Passed = $missingHeaders.Count -eq 0
        Details = if ($missingHeaders.Count -eq 0) { 
            "All required security headers present" 
        } else { 
            "Missing headers: $($missingHeaders -join ', ')" 
        }
    }
}

# Test 2: HTTPS Enforcement
Test-SecurityCheck "HTTPS Enforcement" {
    $httpUrl = $BaseUrl -replace "https://", "http://"
    try {
        $response = Invoke-WebRequest -Uri "$httpUrl/api/v1/health" -Method Get -MaximumRedirection 0 -ErrorAction Stop -UseBasicParsing
        return @{
            Passed = $false
            Details = "HTTP request was not redirected to HTTPS"
        }
    } catch {
        if ($_.Exception.Response.StatusCode -eq 301 -or $_.Exception.Response.StatusCode -eq 302) {
            return @{
                Passed = $true
                Details = "HTTP requests are properly redirected to HTTPS"
            }
        }
        return @{
            Passed = $true
            Details = "HTTP endpoint not accessible (expected in production)"
        }
    }
}

# Test 3: SQL Injection Protection
Test-SecurityCheck "SQL Injection Protection" {
    $sqlInjectionPayloads = @(
        "' OR '1'='1",
        "1; DROP TABLE Articles--",
        "admin'--"
    )
    
    $vulnerable = $false
    foreach ($payload in $sqlInjectionPayloads) {
        try {
            $encodedPayload = [System.Web.HttpUtility]::UrlEncode($payload)
            $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/articles/search?query=$encodedPayload" -Method Get -UseBasicParsing
            
            # Check if response contains SQL error messages
            if ($response.Content -match "SQL|syntax|database|mysql|postgresql") {
                $vulnerable = $true
                break
            }
        } catch {
            # Errors are expected for malicious input
        }
    }
    
    return @{
        Passed = -not $vulnerable
        Details = if ($vulnerable) { 
            "Application may be vulnerable to SQL injection" 
        } else { 
            "SQL injection attempts properly handled" 
        }
    }
}

# Test 4: XSS Protection
Test-SecurityCheck "XSS Protection" {
    $xssPayloads = @(
        "<script>alert('xss')</script>",
        "javascript:alert('xss')",
        "<img src=x onerror=alert('xss')>"
    )
    
    $vulnerable = $false
    foreach ($payload in $xssPayloads) {
        try {
            $body = @{
                articleId = 1
                authorName = "Test"
                authorEmail = "test@example.com"
                content = $payload
            } | ConvertTo-Json
            
            $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/comments" -Method Post -Body $body -ContentType "application/json" -UseBasicParsing
            
            # If request succeeds with XSS payload, it's a problem
            if ($response.StatusCode -eq 200 -or $response.StatusCode -eq 201) {
                $vulnerable = $true
                break
            }
        } catch {
            # Errors are expected for malicious input
        }
    }
    
    return @{
        Passed = -not $vulnerable
        Details = if ($vulnerable) { 
            "Application may be vulnerable to XSS attacks" 
        } else { 
            "XSS attempts properly blocked" 
        }
    }
}

# Test 5: Authentication Required for Admin Endpoints
Test-SecurityCheck "Authentication Required" {
    try {
        $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/admin/articles" -Method Get -UseBasicParsing
        return @{
            Passed = $false
            Details = "Admin endpoint accessible without authentication"
        }
    } catch {
        if ($_.Exception.Response.StatusCode -eq 401) {
            return @{
                Passed = $true
                Details = "Admin endpoints properly protected"
            }
        }
        return @{
            Passed = $false
            Details = "Unexpected response: $($_.Exception.Response.StatusCode)"
        }
    }
}

# Test 6: Rate Limiting
Test-SecurityCheck "Rate Limiting" {
    $requestCount = 150
    $blockedCount = 0
    
    for ($i = 1; $i -le $requestCount; $i++) {
        try {
            $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/health" -Method Get -UseBasicParsing
        } catch {
            if ($_.Exception.Response.StatusCode -eq 429) {
                $blockedCount++
            }
        }
    }
    
    return @{
        Passed = $blockedCount -gt 0
        Details = if ($blockedCount -gt 0) { 
            "Rate limiting active: $blockedCount/$requestCount requests blocked" 
        } else { 
            "Rate limiting may not be configured" 
        }
    }
}

# Test 7: Information Disclosure
Test-SecurityCheck "Information Disclosure Prevention" {
    $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/health" -Method Get -UseBasicParsing
    $headers = $response.Headers
    
    $disclosureHeaders = @("Server", "X-Powered-By", "X-AspNet-Version", "X-AspNetMvc-Version")
    $foundHeaders = $disclosureHeaders | Where-Object { $headers.ContainsKey($_) }
    
    return @{
        Passed = $foundHeaders.Count -eq 0
        Details = if ($foundHeaders.Count -eq 0) { 
            "No information disclosure headers found" 
        } else { 
            "Information disclosure headers present: $($foundHeaders -join ', ')" 
        }
    }
}

# Test 8: CORS Configuration
Test-SecurityCheck "CORS Configuration" {
    $headers = @{
        "Origin" = "https://evil.com"
    }
    
    try {
        $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/articles" -Method Get -Headers $headers -UseBasicParsing
        
        if ($response.Headers.ContainsKey("Access-Control-Allow-Origin")) {
            $allowedOrigin = $response.Headers["Access-Control-Allow-Origin"]
            if ($allowedOrigin -eq "*" -or $allowedOrigin -eq "https://evil.com") {
                return @{
                    Passed = $false
                    Details = "CORS allows unauthorized origins"
                }
            }
        }
        
        return @{
            Passed = $true
            Details = "CORS properly configured"
        }
    } catch {
        return @{
            Passed = $true
            Details = "CORS properly restricts origins"
        }
    }
}

# Test 9: Path Traversal Protection
Test-SecurityCheck "Path Traversal Protection" {
    $pathTraversalPayloads = @(
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "%2e%2e%2f%2e%2e%2f"
    )
    
    $vulnerable = $false
    foreach ($payload in $pathTraversalPayloads) {
        try {
            $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/articles/$payload" -Method Get -UseBasicParsing
            
            # If we get a 200 response with file content, it's vulnerable
            if ($response.StatusCode -eq 200 -and $response.Content.Length -gt 0) {
                $vulnerable = $true
                break
            }
        } catch {
            # Errors are expected for malicious input
        }
    }
    
    return @{
        Passed = -not $vulnerable
        Details = if ($vulnerable) { 
            "Application may be vulnerable to path traversal" 
        } else { 
            "Path traversal attempts properly blocked" 
        }
    }
}

# Test 10: Clickjacking Protection
Test-SecurityCheck "Clickjacking Protection" {
    $response = Invoke-WebRequest -Uri "$BaseUrl/api/v1/health" -Method Get -UseBasicParsing
    $headers = $response.Headers
    
    $hasXFrameOptions = $headers.ContainsKey("X-Frame-Options")
    $hasCSPFrameAncestors = $false
    
    if ($headers.ContainsKey("Content-Security-Policy")) {
        $csp = $headers["Content-Security-Policy"]
        $hasCSPFrameAncestors = $csp -match "frame-ancestors"
    }
    
    return @{
        Passed = $hasXFrameOptions -or $hasCSPFrameAncestors
        Details = if ($hasXFrameOptions -or $hasCSPFrameAncestors) { 
            "Clickjacking protection enabled" 
        } else { 
            "No clickjacking protection found" 
        }
    }
}

# Generate Report
Write-Host ""
Write-Host "==================================" -ForegroundColor Cyan
Write-Host "Test Results Summary" -ForegroundColor Cyan
Write-Host "==================================" -ForegroundColor Cyan
Write-Host "Total Tests: $($passCount + $failCount)" -ForegroundColor White
Write-Host "Passed: $passCount" -ForegroundColor Green
Write-Host "Failed: $failCount" -ForegroundColor Red
Write-Host ""

# Save results to file
$results | Format-Table -AutoSize | Out-File -FilePath $OutputPath
Write-Host "Detailed results saved to: $OutputPath" -ForegroundColor Yellow

# Exit with appropriate code
if ($failCount -gt 0) {
    Write-Host ""
    Write-Host "Security issues detected! Please review the failed tests." -ForegroundColor Red
    exit 1
} else {
    Write-Host ""
    Write-Host "All security tests passed!" -ForegroundColor Green
    exit 0
}
